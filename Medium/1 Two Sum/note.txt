妈的，这明明一道非常简单的题，我SB死了・・・

brute force O(n^2)貌似可行，不说什么了・・・

我的思路是先排序，然后查找。O(nlogn)
不过这种办法实现麻烦，而且要讨论多种情况・・・

比如有两个4，相加为8啥的，查找的那个index不能和初始的一样・・


后来想到用multimap，时间也是O（nlogn），不过几乎不用实现・・・・

最佳的方法当然是hash，但是我竟然没有想到・・・为什么说自己sb・・・

一看到查找，第一反应就应该是hash啊！！！

2016.1.20
话说这题还有个很好的思路，虽说时间是O(nlgn), 但是很有启发性。
先排序，然后用两根指针，一前一后。

相加若为正，后面的指针向前。
相加若为负，前面的指针往后走。

对3sum那个题很有启发性！